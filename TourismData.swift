
import Foundation
import CoreML

// Auto-generated tourism data for iOS app
// Generated by kathmandu_tourism_vectorizer.py

struct TourismPlace: Codable, Identifiable {
    let id: String
    let name: String
    let nameNepali: String?
    let category: String
    let shortDescription: String
    let latitude: Double
    let longitude: Double
    let area: String
    let tags: [String]
    let highlights: [String]
    let tips: [String]
    let googleRating: Double?
    let timeNeeded: String?
    let embedding: [Float]
}

class TourismDataManager {
    static let shared = TourismDataManager()
    
    lazy var places: [TourismPlace] = {
        return loadPlaces()
    }()
    
    private func loadPlaces() -> [TourismPlace] {
        // Load from bundled JSON
        guard let url = Bundle.main.url(forResource: "tourism_data", withExtension: "json"),
              let data = try? Data(contentsOf: url),
              let places = try? JSONDecoder().decode([TourismPlace].self, from: data) else {
            return []
        }
        return places
    }
    
    // Cosine similarity search
    func search(query embedding: [Float], topK: Int = 5) -> [TourismPlace] {
        let similarities = places.map { place -> (TourismPlace, Float) in
            let similarity = cosineSimilarity(embedding, place.embedding)
            return (place, similarity)
        }
        
        return similarities
            .sorted { $0.1 > $1.1 }
            .prefix(topK)
            .map { $0.0 }
    }
    
    private func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {
        guard a.count == b.count else { return 0 }
        
        var dotProduct: Float = 0
        var normA: Float = 0
        var normB: Float = 0
        
        for i in 0..<a.count {
            dotProduct += a[i] * b[i]
            normA += a[i] * a[i]
            normB += b[i] * b[i]
        }
        
        let denominator = sqrt(normA) * sqrt(normB)
        return denominator > 0 ? dotProduct / denominator : 0
    }
    
    // Filter by category
    func places(inCategory category: String) -> [TourismPlace] {
        return places.filter { $0.category == category }
    }
    
    // Filter by area
    func places(inArea area: String) -> [TourismPlace] {
        return places.filter { $0.area == area }
    }
    
    // Find nearby places
    func nearbyPlaces(latitude: Double, longitude: Double, radiusKm: Double = 2.0) -> [TourismPlace] {
        return places.filter { place in
            let distance = haversineDistance(
                lat1: latitude, lon1: longitude,
                lat2: place.latitude, lon2: place.longitude
            )
            return distance <= radiusKm
        }
    }
    
    private func haversineDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double) -> Double {
        let R = 6371.0 // Earth's radius in km
        let dLat = (lat2 - lat1) * .pi / 180
        let dLon = (lon2 - lon1) * .pi / 180
        let a = sin(dLat/2) * sin(dLat/2) +
                cos(lat1 * .pi / 180) * cos(lat2 * .pi / 180) *
                sin(dLon/2) * sin(dLon/2)
        let c = 2 * atan2(sqrt(a), sqrt(1-a))
        return R * c
    }
}
